---
date: 2021-10-03T09:47
---

# Combinator

A combinator is a pure function that only references its argument (i.e. doesn't
use anything from any external scope).

For example:

```haskell
sum xs = foldr (+) 0 xs
```

is not a combinator, since it references `foldr` and `(+)` (presumed to be
defined elsewhere) which are not arguments to `sum`. Meanwhile,

```haskell
compose f g x = g (f x)
```

is a combinator since it only uses its arguments, `f`, `g`, and `x`, not
referencing any name defined elsewhere.

## Examples

- [[eed5e870]]#

## See also

- [_Point Free or Die_](https://www.youtube.com/watch?v=seVSlKazsNk)
- [_An Introduction to Combinator Compilers and Graph Reduction Machines_](https://www.youtube.com/watch?v=GawiQQCn3bk)
    - [Reduceron](https://github.com/tommythorn/Reduceron)

## Combinator Calculus

A combinator calculus is a combinatory logic system similar to the lambda
calulus. Each atom in the calculus (sort of) corresponds to a lambda calculus
expression. Useful as objects of study because many are [[065a02c9]]. For
example, the **SKI** calculus,

$$
I x = x
$$
$$
K x y = x
$$
$$
S f g x = (f x) (g x)
$$

Another example is the universal iota, a single combinator which can express S,
K, and I through different associations.

$$
{\displaystyle \iota :=\lambda f.((fS)K):=\lambda f.((f\lambda a.\lambda b.\lambda c.((ac)(bc)))\lambda d.\lambda e.d)}
$$

$$
{\displaystyle I\,=\,(\iota \iota ),\;K\,=\,(\iota (\iota (\iota \iota ))),\;S\,=\,(\iota (\iota (\iota (\iota \iota ))))}
$$

### See also

- [_SKI Combinator Calculus_, Wikipedia](https://en.wikipedia.org/wiki/SKI_combinator_calculus)
- [_Iota and Jot_, Wikipedia](https://en.wikipedia.org/wiki/Iota_and_Jot)
- [_HaSKI_](https://yager.io/HaSKI/HaSKI.html)
